{% extends "base.html" %}

{% block content %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/3.3.2/tailwind.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

<div class="flex gap-6 max-w-7xl mx-auto p-6">
    <!-- Left column: controls + cards -->
    <div class="w-2/3">
        <h1 class="text-3xl font-bold mb-6">Merge PDFs</h1>

        <!-- Upload Box -->
        <div class="mb-2">
            <label class="block mb-2 font-semibold">Upload PDFs</label>
            <div id="upload-box" class="relative border-2 border-dashed border-gray-400 rounded-lg p-6 flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 transition-colors">
                <div class="text-6xl mb-4 text-gray-400">üìÅ</div>
                <p class="text-gray-600 text-center">Drag & Drop PDFs here or click to select files</p>
                <input type="file" id="pdf-input" accept="application/pdf" multiple class="absolute w-full h-full opacity-0 cursor-pointer">
            </div>
        </div>

        <!-- Buttons -->
        <div class="flex gap-2 mt-2">
            <button id="clear-all" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">Clear All</button>
        </div>

        <!-- Default PDF checkbox -->
        <div class="mb-6 flex items-center gap-2 mt-2">
            <input type="checkbox" id="include-default" class="h-4 w-4">
            <label for="include-default" class="font-medium">Include Default PDF</label>
        </div>

        <h2 class="text-xl font-semibold mb-2">Arrange PDFs</h2>
        <div id="pdf-list" class="grid grid-cols-3 gap-4"></div>

        <div class="mt-6 flex gap-3">
            <button id="merge-btn" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700">Download Merged PDF</button>
        </div>
    </div>

    <!-- Right column: scrollable merged preview -->
    <div class="w-1/3">
        <div class="sticky top-6 space-y-6">
            <div class="border rounded-lg shadow p-4 bg-white">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="font-semibold">Live Merged Preview</h3>
                    <div id="merged-meta" class="text-sm text-gray-500">Not generated</div>
                </div>
                <div id="merged-preview" class="w-full h-[800px] border bg-gray-50 overflow-auto flex items-center justify-center">
                    <div id="merged-placeholder" class="text-gray-400">No PDFs selected</div>
                </div>
                <div class="mt-3 flex gap-2">
                    <a id="download-merged" class="ml-auto bg-blue-600 text-white px-4 py-1 rounded hover:bg-blue-700 hidden" href="#" download="merged.pdf">Download</a>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.pdf-card {
    transition: transform 0.2s ease, opacity 0.2s ease;
}
.pdf-card.dragging {
    opacity: 0.5;
    transform: scale(0.98);
}
.remove-btn {
    transition: transform 0.15s, color 0.15s;
}
.remove-btn:hover {
    transform: scale(1.1);
    color: red;
}
.card-thumb {
    width: 120px;
    height: 160px;
    border-radius: 6px;
    overflow: hidden;
    background: #f8fafc;
    display: flex;
    align-items: center;
    justify-content: center;
}
.card-filename {
    max-width: 120px;
    text-align: center;
    font-size: 12px;
    margin-top: 8px;
    word-break: break-word;
}
.card-actions { position: absolute; top: 6px; right: 6px; display:flex; gap:6px; align-items:center; }
.card-container { position: relative; padding-top: 8px; padding-bottom: 12px; display:flex; flex-direction:column; align-items:center; }
</style>

<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

let pdfList = [];
let defaultIncluded = false;

const input = document.getElementById('pdf-input');
const list = document.getElementById('pdf-list');
const clearAllBtn = document.getElementById('clear-all');
const includeDefault = document.getElementById('include-default');
const mergeBtn = document.getElementById('merge-btn');

const mergedPreview = document.getElementById('merged-preview');
const mergedPlaceholder = document.getElementById('merged-placeholder');
const mergedMeta = document.getElementById('merged-meta');
const downloadMerged = document.getElementById('download-merged');

let dragged = null;

/* ---------- Helpers ---------- */
function fileToArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = reject;
        fr.readAsArrayBuffer(file);
    });
}

async function generateThumbnail(file) {
    try {
        const ab = await fileToArrayBuffer(file);
        const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 0.2 });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
        pdf.destroy();
        return canvas.toDataURL('image/png');
    } catch(e) {
        console.warn('Thumbnail error', e);
        return null;
    }
}

/* ---------- Render PDF cards ---------- */
async function renderList() {
    list.innerHTML = '';
    pdfList = pdfList.filter(p => !p.isDefault || defaultIncluded);

    if (defaultIncluded && !pdfList.some(p => p.isDefault)) {
        pdfList.push({ file: null, name: 'Default PDF', isDefault: true, thumbDataUrl: null });
    }

    for (let i = 0; i < pdfList.length; i++) {
        const pdf = pdfList[i];

        const card = document.createElement('div');
        card.className = 'pdf-card border rounded p-3 card-container bg-white flex flex-col items-center justify-start';
        card.draggable = true;
        card.dataset.index = i;

        const thumbWrap = document.createElement('div');
        thumbWrap.className = 'card-thumb';

        if (pdf.file && !pdf.thumbDataUrl) {
            pdf.thumbDataUrl = await generateThumbnail(pdf.file);
        }

        if (pdf.thumbDataUrl) {
            const img = document.createElement('img');
            img.src = pdf.thumbDataUrl;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            thumbWrap.appendChild(img);
        } else {
            thumbWrap.textContent = 'üìÑ';
        }

        const fname = document.createElement('div');
        fname.className = 'card-filename';
        fname.textContent = pdf.name;

        const actions = document.createElement('div');
        actions.className = 'card-actions';
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '&times;';
        removeBtn.className = 'remove-btn text-gray-600 bg-white border rounded px-1';
        removeBtn.addEventListener('click', ev => {
            ev.stopPropagation();
            if (pdf.isDefault) defaultIncluded = false;
            pdfList.splice(i, 1);
            renderList();
        });
        actions.appendChild(removeBtn);

        card.appendChild(actions);
        card.appendChild(thumbWrap);
        card.appendChild(fname);

        card.addEventListener('dragstart', () => { dragged = card; card.classList.add('dragging'); });
        card.addEventListener('dragend', () => { card.classList.remove('dragging'); dragged = null; });
        card.addEventListener('dragover', e => e.preventDefault());
        card.addEventListener('drop', e => {
            e.preventDefault();
            if (!dragged || dragged === card) return;
            const children = Array.from(list.children);
            const fromIndex = children.indexOf(dragged);
            const toIndex = children.indexOf(card);
            const moved = pdfList.splice(fromIndex, 1)[0];
            pdfList.splice(toIndex, 0, moved);
            renderList();
        });

        list.appendChild(card);
    }

    includeDefault.checked = pdfList.some(p => p.isDefault);
    updateMergedPreview();
}

/* ---------- Update merged preview ---------- */
async function updateMergedPreview() {
    mergedPreview.innerHTML = '';
    if (pdfList.length === 0) {
        mergedPlaceholder.style.display = 'block';
        mergedPlaceholder.textContent = 'No PDFs selected';
        downloadMerged.classList.add('hidden');
        mergedMeta.textContent = 'Not generated';
        return;
    }

    mergedPlaceholder.style.display = 'block';
    mergedPlaceholder.textContent = 'Rendering merged preview...';

    try {
        const mergedPdf = await PDFLib.PDFDocument.create();
        for (const pdf of pdfList) {
            if (!pdf.file) continue;
            const ab = await pdf.file.arrayBuffer();
            const donorPdf = await PDFLib.PDFDocument.load(ab);
            const copiedPages = await mergedPdf.copyPages(donorPdf, donorPdf.getPageIndices());
            copiedPages.forEach(page => mergedPdf.addPage(page));
        }
        const mergedBytes = await mergedPdf.save();
        const blob = new Blob([mergedBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);

        const iframe = document.createElement('iframe');
        iframe.src = url;
        iframe.width = '100%';
        iframe.height = '100%';
        iframe.style.border = 'none';
        mergedPreview.appendChild(iframe);

        mergedPlaceholder.style.display = 'none';
        downloadMerged.href = url;
        downloadMerged.classList.remove('hidden');
        mergedMeta.textContent = new Date().toLocaleString();
    } catch(err) {
        mergedPlaceholder.textContent = 'Failed to render merged preview';
        console.error(err);
    }
}

/* ---------- Event listeners ---------- */
input.addEventListener('change', async e => {
    const files = Array.from(e.target.files).filter(f => f.type === 'application/pdf');
    for (const f of files) {
        pdfList.push({ file: f, name: f.name, isDefault: false, thumbDataUrl: null });
    }
    renderList();
});

['dragover','dragleave','drop'].forEach(evt => {
    const fn = evt === 'dragover' ? e => { e.preventDefault(); uploadBox.classList.add('border-blue-500','bg-blue-50'); } :
               evt === 'dragleave' ? e => uploadBox.classList.remove('border-blue-500','bg-blue-50') :
               async e => {
                   e.preventDefault(); uploadBox.classList.remove('border-blue-500','bg-blue-50');
                   const files = Array.from(e.dataTransfer.files).filter(f=>f.type==='application/pdf');
                   for(const f of files){ pdfList.push({file:f,name:f.name,isDefault:false,thumbDataUrl:null}); renderList(); }
               };
    uploadBox.addEventListener(evt, fn);
});

includeDefault.addEventListener('change', () => { defaultIncluded = includeDefault.checked; renderList(); });
clearAllBtn.addEventListener('click', () => { pdfList=[]; defaultIncluded=false; renderList(); });

mergeBtn.addEventListener('click', async () => {
    if(pdfList.length===0) return alert('No PDFs to merge');
    const mergedPdf = await PDFLib.PDFDocument.create();
    for(const pdf of pdfList){
        if(!pdf.file) continue;
        const ab = await pdf.file.arrayBuffer();
        const donorPdf = await PDFLib.PDFDocument.load(ab);
        const copiedPages = await mergedPdf.copyPages(donorPdf, donorPdf.getPageIndices());
        copiedPages.forEach(page=>mergedPdf.addPage(page));
    }
    const mergedBytes = await mergedPdf.save();
    const blob = new Blob([mergedBytes], { type:'application/pdf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'merged.pdf';
    a.click();
});

renderList();
</script>
{% endblock %}
